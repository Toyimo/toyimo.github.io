[{"title":"C++ Notes(1): Lambda expressions","date":"2018-07-21T02:19:11.000Z","path":"2018/07/21/C-Notes-1-Lambda-expressions/","text":"“Lambda 表达式”是一个匿名函数，其基于数学中的 λ\\lambdaλ 演算得名，直接对应于其中的Lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包，但这一概念与数学上的闭包不同。本文旨在介绍Lamda表达式的语法规则以及在程序中的常规用法。 Lambda Expressions Syntax λ\\lambdaλ 演算可以被称为最小的通用程序设计语言。它包括一条变换规则 (变量替换) 和一条函数定义方式， λ\\lambdaλ 演算之通用在于，任何一个可计算函数都能用这种形式来表达和求值。 在 λ\\lambdaλ 演算中，每个表达式都代表一个只有单独参数的函数，这个函数的参数本身也是一个只有单一参数的函数，同时，函数的值又是一个只有单一参数的函数。函数是通过 λ\\lambdaλ 表达式匿名地定义的，这个表达式说明了此函数将对其参数进行什么操作。例如，函数 f(x)=x+2f(x)=x+2f(x)=x+2 可以用 λ 演算表示为 λ x.x+2\\lambda\\ \\ x.x+2λ x.x+2。 在C++语言中，其语法规则如下: ▌语法形式[1] 1234[captures] &lt;tparams&gt;(可选) (params) specifiers(可选) -&gt; ret &#123;body&#125;[captures] (params) -&gt; ret &#123;body&#125; [captures] (params) &#123;body&#125;[captures] &#123;body&#125; 上述语法中： (1) Lambda表达式的完整声明。 (2) 声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。 (3) 省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： - 如果函数体中存在return语句，则返回类型由return语句的返回类型确定; - 如果函数体中没有return语句，则返回值为void类型. (4) 省略参数列表：函数不接收参数，即参数列表为 ()，类似于普通函数中的无参函数。 ▌语法解释 参数 解释 captures 表达式捕获外部参数列表，其有如下形式： [];[&amp;];[=];[=,&amp;foo];[bar];[this] &lt;tparams&gt; 模板形参列表（于角括号中），用于提供名称给泛型表达式的模板形参 params 形参列表 specifiers 可选的指定符序列。允许下列指定符：mutable：允许 body 修改已复制的捕获参数，及调用其non-const 成员函数exception：说明表达式是否抛出异常以及何种异常attribute：用来声明属性 ret 返回类型，若缺失，则由函数的return语句推断返回值类型（或若函数不返回任何值则为void） body 匿名函数体 Properties of Lambda Expressions 下图映射了上文所介绍的Lambda表达式的语法规则[2]： 图中标注的含义如下： (1) 表达式捕获外部参数列表； (2) 形参列表； (3) 可选的指定符序列：可变指定符； (4) 可选的指定符序列：异常指定符； (5) 返回类型； (6) 表达式的匿名函数体。 这里需要详细介绍捕获外部参数列表中参数的几种形式，下文例子中体现了这一部分的内容[3]： []：没有使用任何函数对象参数，不捕获任何对象。 [=]：函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 [&amp;]：函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。 [this]：函数体内可以使用Lambda所在类中的成员变量。 [bar]：将bar按值进行传递。按值进行传递时，函函数体内不能修改传递进来的bar的拷贝，因为默认情况下函数是const的。要修改传递进来的bar的拷贝，可以添加mutable修饰符。 [&amp;foo]：将foo按引用进行传递。 [bar,&amp;foo]：将bar按值进行传递，foo按引用进行传递。 [=,&amp;a,&amp;b]：除a和b按引用进行传递外，其他参数都按值进行传递。 [&amp;,a,b]：除a和b按值进行传递外，其他参数都按引用进行传递。 Examples Lambda函数体可访问其所在主体函数的如下类型的变量： - 参数 - 本地声明的变量 - 在类内声明的数据成员 - 任何具有静态存储时间的变量（如全局变量） 没有在Lambda表达式的捕获子句中但出现在Lambda函数体中的变量为 隐式捕获，否则为 显式捕获，下面的例子中包含了一个显示捕获的变量n和隐式捕获的变量m。 123456789101112// captures_lambda_expression.cpp// compile with: /W4 /EHsc#include &lt;iostream&gt;using namespace std;int main()&#123; int m = 0; int n = 0; [&amp;, n] (int a) mutable &#123; m = ++n + a; &#125;(4); cout &lt;&lt; m &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;&#125; 上述代码输出为： 5 0 由于`n`为按值捕获的变量，所以当其响应完Lambda表达式后主体函数汇中的值仍为0。 下面的例子在STL中的generate_n算法中借助Lambda表达式实现重设vector中任意元素为前两个元素的和。例子中使用了mutable指定符使得表达式中拷贝的变量x和y可以被修改，但因为这两个变量是按值拷贝的，所以在表达式执行结束之后，变量x和y仍然为1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// compile with: /W4 /EHsc#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;template &lt;typename C&gt; void print(const string&amp; s, const C&amp; c) &#123; cout &lt;&lt; s; for (const auto&amp; e : c) &#123; cout &lt;&lt; e &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void fillVector(vector&lt;int&gt;&amp; v)&#123; // A local static variable. static int nextValue = 1; // The lambda expression that appears in the following call to // the generate function modifies and uses the local static // variable nextValue. generate(v.begin(), v.end(), [] &#123; return nextValue++; &#125;); //WARNING: this is not thread-safe and is shown for illustration only&#125;int main()&#123; // The number of elements in the vector. const int elementCount = 9; // Create a vector object with each element set to 1. vector&lt;int&gt; v(elementCount, 1); // These variables hold the previous two elements of the vector. int x = 1; int y = 1; // Sets each element in the vector to the sum of the // previous two elements. generate_n(v.begin() + 2, elementCount - 2, [=]() mutable throw() -&gt; int &#123; // lambda is the 3rd parameter // Generate current value. int n = x + y; // Update previous two values. x = y; y = n; return n; &#125;); print(\"vector v after call to generate_n() with lambda: \", v); // Print the local variables x and y. // The values of x and y hold their initial values because // they are captured by value. cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; endl; // Fill the vector with a sequence of numbers fillVector(v); print(\"vector v after 1st call to fillVector(): \", v); // Fill the vector with the next sequence of numbers fillVector(v); print(\"vector v after 2nd call to fillVector(): \", v);&#125; 上述代码输出为： vector v after call to generate_n() with lambda: 1 1 2 3 5 8 13 21 34 x: 1 y: 1 vector v after 1st call to fillVector(): 1 2 3 4 5 6 7 8 9 vector v after 2nd call to fillVector(): 10 11 12 13 14 15 16 17 18 cppreference.Lambda 表达式.Link ↩︎ 微软帮助中心.Lambda Expression Syntax.Link ↩︎ 糖炒栗子Sugar.C++ Lambda表达式用法.Link ↩︎","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hello, I'm Jaxin","date":"2018-07-11T01:12:52.000Z","path":"2018/07/11/Hello-I-m-Jaxin/","text":"“经霜雪而无迹，照日光而无景，扶摇抮抱羊角而上，经纪山川，蹈腾昆仑。” 序 值此开博，谢@Homxu相助。此间诸博客，或为远近见闻，或为理论研究，或为捉虫游戏，或为其他杂文散记，行之至远，方得趣味。今博客既成，日后若以他人学识为纲，未免白费一番心思，自当以个人见解，驱虫以得草木之茵茵。 总之，我们的宗旨是：兄长，我想带一虫回云深不知处，带回去，藏起来( • ̀ω•́ )✧。 “事实是，当你犹豫要不要去做一件事的时候，其实你内心已经有了选择，只是你还没有充足的理由去说服自己。”东野圭吾《解忧杂货铺》 So, let’s go.","tags":[{"name":"闲广录","slug":"闲广录","permalink":"http://yoursite.com/tags/闲广录/"}]},{"title":"Hello World","date":"2018-07-11T00:47:05.517Z","path":"2018/07/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","tags":[]}]